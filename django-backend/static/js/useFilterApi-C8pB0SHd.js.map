{"version":3,"file":"useFilterApi-C8pB0SHd.js","sources":["../../../src/components/common/dynamic-table/hooks/useFilterApi.ts"],"sourcesContent":["import { useState } from 'react';\nimport { SetFilters } from '@/components/filter/filter.types';\nimport axios from 'axios';\n\ninterface UseFilterApiProps {\n  endpoint: string;\n  initialData?: any[];\n  baseQueryParams?: Record<string, any>;\n}\n\ninterface FilterApiResponse<T> {\n  data: T[];\n  loading: boolean;\n  error: Error | null;\n  search: (term: string) => Promise<T[]>;\n  filterByDateRange: (from?: Date, to?: Date) => Promise<T[]>;\n  filterByStatus: (status: string) => Promise<T[]>;\n  filterBySelect: (id: string, value: string) => Promise<T[]>;\n  applyFilters: (filters: SetFilters) => Promise<T[]>;\n  resetFilters: () => Promise<T[]>;\n}\n\n/**\n * Hook for handling API-based filtering\n * @param endpoint - The API endpoint to call for filtering\n * @param initialData - Optional initial data to use when no filters are applied\n * @param baseQueryParams - Optional base query parameters to include in all requests\n */\nexport function useFilterApi<T = any>({ \n  endpoint, \n  initialData = [], \n  baseQueryParams = {} \n}: UseFilterApiProps): FilterApiResponse<T> {\n  const [data, setData] = useState<T[]>(initialData);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Helper function to make API calls\n  const fetchFilteredData = async (params: Record<string, any>): Promise<T[]> => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      // Combine base query params with the specific filter params\n      const queryParams = { ...baseQueryParams, ...params };\n      \n      const response = await axios.get(endpoint, { params: queryParams });\n      const result = response.data;\n      \n      setData(result);\n      return result;\n    } catch (err: any) {\n      setError(err);\n      return initialData;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Search by term\n  const search = async (term: string): Promise<T[]> => {\n    return fetchFilteredData({ search: term });\n  };\n\n  // Filter by date range\n  const filterByDateRange = async (from?: Date, to?: Date): Promise<T[]> => {\n    const params: Record<string, any> = {};\n    if (from) params.fromDate = from.toISOString();\n    if (to) params.toDate = to.toISOString();\n    return fetchFilteredData(params);\n  };\n\n  // Filter by status\n  const filterByStatus = async (status: string): Promise<T[]> => {\n    // Don't include status if it's \"all\"\n    if (status === 'all') {\n      return fetchFilteredData({});\n    }\n    return fetchFilteredData({ status });\n  };\n\n  // Filter by custom select field\n  const filterBySelect = async (id: string, value: string): Promise<T[]> => {\n    // Don't include value if it's \"all\"\n    if (value === 'all') {\n      return fetchFilteredData({});\n    }\n    return fetchFilteredData({ [id]: value });\n  };\n\n  // Apply all filters at once\n  const applyFilters = async (filters: SetFilters): Promise<T[]> => {\n    const params: Record<string, any> = {};\n\n    // Add search term if present\n    if (filters.search) {\n      params.search = filters.search;\n    }\n\n    // Add date range if present\n    if (filters.dateRange.from) {\n      params.fromDate = filters.dateRange.from.toISOString();\n    }\n    if (filters.dateRange.to) {\n      params.toDate = filters.dateRange.to.toISOString();\n    }\n\n    // Add status if present and not \"all\"\n    if (filters.status && filters.status !== 'all') {\n      params.status = filters.status;\n    }\n\n    // Add role if present\n    if (filters.role && filters.role !== '') {\n      params.role = filters.role;\n    }\n\n    // Add custom filter values\n    for (const [key, value] of Object.entries(filters.customFilterValues)) {\n      if (value && value !== 'all') {\n        params[key] = value;\n      }\n    }\n\n    return fetchFilteredData(params);\n  };\n\n  // Reset filters and fetch initial data\n  const resetFilters = async (): Promise<T[]> => {\n    setData(initialData);\n    return initialData;\n  };\n\n  return {\n    data,\n    loading,\n    error,\n    search,\n    filterByDateRange,\n    filterByStatus,\n    filterBySelect,\n    applyFilters,\n    resetFilters\n  };\n}\n"],"names":["useFilterApi","endpoint","initialData","baseQueryParams","data","setData","useState","loading","setLoading","error","setError","fetchFilteredData","params","queryParams","result","axios","err","term","from","to","status","id","value","filters","key"],"mappings":"0FA4BO,SAASA,EAAsB,CACpC,SAAAC,EACA,YAAAC,EAAc,CAAC,EACf,gBAAAC,EAAkB,CAAA,CACpB,EAA4C,CAC1C,KAAM,CAACC,EAAMC,CAAO,EAAIC,EAAAA,SAAcJ,CAAW,EAC3C,CAACK,EAASC,CAAU,EAAIF,EAAAA,SAAS,EAAK,EACtC,CAACG,EAAOC,CAAQ,EAAIJ,EAAAA,SAAuB,IAAI,EAG/CK,EAAoB,MAAOC,GAA8C,CAC7EJ,EAAW,EAAI,EACfE,EAAS,IAAI,EAET,GAAA,CAEF,MAAMG,EAAc,CAAE,GAAGV,EAAiB,GAAGS,CAAO,EAG9CE,GADW,MAAMC,EAAM,IAAId,EAAU,CAAE,OAAQY,EAAa,GAC1C,KAExB,OAAAR,EAAQS,CAAM,EACPA,QACAE,EAAU,CACjB,OAAAN,EAASM,CAAG,EACLd,CAAA,QACP,CACAM,EAAW,EAAK,CAAA,CAEpB,EA4EO,MAAA,CACL,KAAAJ,EACA,QAAAG,EACA,MAAAE,EACA,OA7Ea,MAAOQ,GACbN,EAAkB,CAAE,OAAQM,EAAM,EA6EzC,kBAzEwB,MAAOC,EAAaC,IAA4B,CACxE,MAAMP,EAA8B,CAAC,EACrC,OAAIM,IAAMN,EAAO,SAAWM,EAAK,YAAY,GACzCC,IAAIP,EAAO,OAASO,EAAG,YAAY,GAChCR,EAAkBC,CAAM,CACjC,EAqEE,eAlEqB,MAAOQ,GAGnBT,EADLS,IAAW,MACY,CAAA,EAEF,CAAE,OAAAA,EAFE,EAgE7B,eA1DqB,MAAOC,EAAYC,IAG/BX,EADLW,IAAU,MACa,CAAA,EAEF,CAAE,CAACD,CAAE,EAAGC,EAFJ,EAwD7B,aAlDmB,MAAOC,GAAsC,CAChE,MAAMX,EAA8B,CAAC,EAGjCW,EAAQ,SACVX,EAAO,OAASW,EAAQ,QAItBA,EAAQ,UAAU,OACpBX,EAAO,SAAWW,EAAQ,UAAU,KAAK,YAAY,GAEnDA,EAAQ,UAAU,KACpBX,EAAO,OAASW,EAAQ,UAAU,GAAG,YAAY,GAI/CA,EAAQ,QAAUA,EAAQ,SAAW,QACvCX,EAAO,OAASW,EAAQ,QAItBA,EAAQ,MAAQA,EAAQ,OAAS,KACnCX,EAAO,KAAOW,EAAQ,MAIb,SAAA,CAACC,EAAKF,CAAK,IAAK,OAAO,QAAQC,EAAQ,kBAAkB,EAC9DD,GAASA,IAAU,QACrBV,EAAOY,CAAG,EAAIF,GAIlB,OAAOX,EAAkBC,CAAM,CACjC,EAiBE,aAdmB,UACnBP,EAAQH,CAAW,EACZA,EAaT,CACF"}